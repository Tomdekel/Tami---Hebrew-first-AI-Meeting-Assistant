import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { dedupeSegmentsByTimeAndText } from "@/lib/transcription/segments";

interface RouteParams {
  params: Promise<{ id: string }>;
}

/**
 * GET /api/sessions/[id]/export
 * Export session as HTML (for printing as PDF) or markdown
 */
export async function GET(request: Request, { params }: RouteParams) {
  try {
    const { id } = await params;
    const { searchParams } = new URL(request.url);
    const format = searchParams.get("format") || "html";
    const includeTranscript = searchParams.get("includeTranscript") === "true";

    const supabase = await createClient();

    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get session with all related data
    const { data: session, error } = await supabase
      .from("sessions")
      .select(`
        id,
        user_id,
        title,
        created_at,
        detected_language,
        duration_seconds,
        summaries (
          overview,
          key_points,
          decisions,
          action_items (
            description,
            assignee,
            deadline,
            completed
          )
        ),
        transcripts (
          transcript_segments (
            speaker_id,
            speaker_name,
            text,
            start_time,
            end_time,
            segment_order
          )
        )
      `)
      .eq("id", id)
      .single();

    if (error || !session) {
      return NextResponse.json({ error: "Session not found" }, { status: 404 });
    }

    if (session.user_id !== user.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    const summary = session.summaries?.[0];
    const transcript = session.transcripts?.[0];
    const isHebrew = session.detected_language === "he";
    const direction = isHebrew ? "rtl" : "ltr";
    const sortedSegments = transcript?.transcript_segments?.sort(
      (a: { segment_order: number }, b: { segment_order: number }) =>
        a.segment_order - b.segment_order
    ) || [];
    const dedupedSegments = dedupeSegmentsByTimeAndText(sortedSegments);

    const title = session.title || "Untitled Meeting";
    const date = new Date(session.created_at).toLocaleDateString(
      isHebrew ? "he-IL" : "en-US",
      {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit",
      }
    );

    const duration = session.duration_seconds
      ? `${Math.floor(session.duration_seconds / 60)}:${(session.duration_seconds % 60).toString().padStart(2, "0")}`
      : "Unknown";

    if (format === "markdown") {
      // Generate Markdown
      let md = `# ${title}\n\n`;
      md += `**${isHebrew ? "תאריך" : "Date"}:** ${date}\n`;
      md += `**${isHebrew ? "משך" : "Duration"}:** ${duration}\n\n`;

      if (summary?.overview) {
        md += `## ${isHebrew ? "סקירה" : "Overview"}\n\n${summary.overview}\n\n`;
      }

      if (summary?.key_points?.length) {
        md += `## ${isHebrew ? "נקודות מפתח" : "Key Points"}\n\n`;
        for (const point of summary.key_points) {
          md += `- ${point}\n`;
        }
        md += "\n";
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const decisions = summary?.decisions as any[];
      if (decisions?.length) {
        md += `## ${isHebrew ? "החלטות" : "Decisions"}\n\n`;
        for (const decision of decisions) {
          md += `- ${decision.description}`;
          if (decision.context) {
            md += ` _(${decision.context})_`;
          }
          md += "\n";
        }
        md += "\n";
      }

      if (summary?.action_items?.length) {
        md += `## ${isHebrew ? "משימות" : "Action Items"}\n\n`;
        for (const item of summary.action_items) {
          const checkbox = item.completed ? "[x]" : "[ ]";
          md += `- ${checkbox} ${item.description}`;
          if (item.assignee) {
            md += ` (${isHebrew ? "משויך ל" : "Assigned to"}: ${item.assignee})`;
          }
          if (item.deadline) {
            md += ` (${isHebrew ? "תאריך יעד" : "Due"}: ${item.deadline})`;
          }
          md += "\n";
        }
        md += "\n";
      }

      if (includeTranscript && transcript?.transcript_segments?.length) {
        md += `## ${isHebrew ? "תמלול" : "Transcript"}\n\n`;
        for (const seg of dedupedSegments) {
          const speaker = seg.speaker_name || seg.speaker_id;
          const time = formatTime(seg.start_time);
          md += `**[${time}] ${speaker}:** ${seg.text}\n\n`;
        }
      }

      md += `---\n_${isHebrew ? "נוצר על ידי תמי" : "Generated by Tami"}_`;

      const mdFilename = encodeFilenameForHeader(title + ".md");
      return new Response(md, {
        headers: {
          "Content-Type": "text/markdown; charset=utf-8",
          "Content-Disposition": `attachment; ${mdFilename}`,
        },
      });
    }

    // Generate HTML (for printing as PDF)
    let html = `<!DOCTYPE html>
<html lang="${isHebrew ? "he" : "en"}" dir="${direction}">
<head>
  <meta charset="UTF-8">
  <title>${escapeHtml(title)}</title>
  <style>
    @page { margin: 2cm; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      line-height: 1.6;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      direction: ${direction};
      text-align: ${isHebrew ? "right" : "left"};
    }
    h1 { color: #1a1a1a; border-bottom: 2px solid #4f46e5; padding-bottom: 10px; }
    h2 { color: #374151; margin-top: 30px; }
    .meta { color: #6b7280; margin-bottom: 30px; }
    .section { margin-bottom: 25px; }
    ul { padding-${isHebrew ? "right" : "left"}: 20px; }
    li { margin-bottom: 8px; }
    .decision { display: flex; align-items: flex-start; gap: 10px; margin-bottom: 10px; }
    .decision-icon { color: #22c55e; }
    .action-item { display: flex; align-items: flex-start; gap: 10px; margin-bottom: 10px; }
    .checkbox { width: 18px; height: 18px; border: 2px solid #d1d5db; border-radius: 4px; flex-shrink: 0; }
    .checkbox.completed { background: #22c55e; border-color: #22c55e; }
    .assignee { color: #6b7280; font-size: 0.9em; }
    .transcript-segment { margin-bottom: 15px; }
    .speaker { font-weight: bold; color: #4f46e5; }
    .timestamp { color: #9ca3af; font-size: 0.85em; }
    .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #9ca3af; font-size: 0.85em; }
    @media print {
      body { padding: 0; }
      .no-print { display: none; }
    }
  </style>
</head>
<body>
  <h1>${escapeHtml(title)}</h1>
  <div class="meta">
    <p><strong>${isHebrew ? "תאריך:" : "Date:"}</strong> ${date}</p>
    <p><strong>${isHebrew ? "משך:" : "Duration:"}</strong> ${duration}</p>
  </div>
`;

    if (summary?.overview) {
      html += `
  <div class="section">
    <h2>${isHebrew ? "סקירה" : "Overview"}</h2>
    <p>${escapeHtml(summary.overview)}</p>
  </div>
`;
    }

    if (summary?.key_points?.length) {
      html += `
  <div class="section">
    <h2>${isHebrew ? "נקודות מפתח" : "Key Points"}</h2>
    <ul>
`;
      for (const point of summary.key_points) {
        html += `      <li>${escapeHtml(point)}</li>\n`;
      }
      html += `    </ul>
  </div>
`;
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const decisions = summary?.decisions as any[];
    if (decisions?.length) {
      html += `
  <div class="section">
    <h2>${isHebrew ? "החלטות" : "Decisions"}</h2>
`;
      for (const decision of decisions) {
        html += `    <div class="decision">
      <span class="decision-icon">✓</span>
      <div>
        <span>${escapeHtml(decision.description)}</span>
        ${decision.context ? `<div class="assignee">${escapeHtml(decision.context)}</div>` : ""}
      </div>
    </div>\n`;
      }
      html += `  </div>
`;
    }

    if (summary?.action_items?.length) {
      html += `
  <div class="section">
    <h2>${isHebrew ? "משימות" : "Action Items"}</h2>
`;
      for (const item of summary.action_items) {
        html += `    <div class="action-item">
      <div class="checkbox ${item.completed ? "completed" : ""}"></div>
      <div>
        <span>${escapeHtml(item.description)}</span>
        ${item.assignee || item.deadline ? `<div class="assignee">` : ""}
        ${item.assignee ? `${isHebrew ? "משויך ל:" : "Assigned to:"} ${escapeHtml(item.assignee)}` : ""}
        ${item.assignee && item.deadline ? " • " : ""}
        ${item.deadline ? `${isHebrew ? "תאריך יעד:" : "Due:"} ${escapeHtml(item.deadline)}` : ""}
        ${item.assignee || item.deadline ? `</div>` : ""}
      </div>
    </div>\n`;
      }
      html += `  </div>
`;
    }

    if (includeTranscript && transcript?.transcript_segments?.length) {
      html += `
  <div class="section">
    <h2>${isHebrew ? "תמלול" : "Transcript"}</h2>
`;
      for (const seg of dedupedSegments) {
        const speaker = seg.speaker_name || seg.speaker_id;
        const time = formatTime(seg.start_time);
        html += `    <div class="transcript-segment">
      <span class="timestamp">[${time}]</span>
      <span class="speaker">${escapeHtml(speaker)}:</span>
      ${escapeHtml(seg.text)}
    </div>\n`;
      }
      html += `  </div>
`;
    }

    html += `
  <div class="footer">
    ${isHebrew ? "נוצר על ידי תמי - פלטפורמת אינטליגנציה לפגישות" : "Generated by Tami - Meeting Intelligence Platform"}
  </div>
</body>
</html>`;

    const htmlFilename = encodeFilenameForHeader(title + ".html");
    return new Response(html, {
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Content-Disposition": `attachment; ${htmlFilename}`,
      },
    });
  } catch (error) {
    console.error("Export error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

function escapeHtml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function sanitizeFilename(name: string): string {
  return name.replace(/[^a-zA-Z0-9\u0590-\u05FF\s-_]/g, "").substring(0, 100);
}

function encodeFilenameForHeader(name: string): string {
  // RFC 5987: Use filename* parameter with UTF-8 encoding for non-ASCII characters
  const sanitized = sanitizeFilename(name);
  const encoded = encodeURIComponent(sanitized).replace(/'/g, "%27");
  // Provide both ASCII fallback and UTF-8 encoded filename
  const asciiName = sanitized.replace(/[^\x20-\x7E]/g, "_");
  return `filename="${asciiName}"; filename*=UTF-8''${encoded}`;
}

function formatTime(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}
